from flask import Flask, render_template, request, jsonify, redirect, url_for
import subprocess
import json
import os
import threading
import time
import logging
from datetime import datetime

logging.basicConfig(level=logging.DEBUG)

app = Flask(__name__)

# Global variables to track mount status and copy progress
status = ""
copy_progress = "Not started"
overall_progress = 0
copy_complete = False

LOG_DIR = 'log'  # Update with the actual log directory path

#@app.route('/logs')
#def logs():
#    try:
#        log_files = []
#        for filename in os.listdir(LOG_DIR):
#            if filename.endswith(".log"):
#                log_path = os.path.join(LOG_DIR, filename)
#                log_files.append({'name': filename, 'path': log_path})
#        return render_template('logs.html', logs=log_files)
#    except Exception as e:
#        return f"Error listing logs: {str(e)}"

@app.route('/logs')
def logs():
    try:
        log_files = []
        for filename in os.listdir(LOG_DIR):
            if filename.endswith(".log"):
                log_path = os.path.join(LOG_DIR, filename)
                last_modified_time = os.path.getmtime(log_path)
                last_modified_date = datetime.fromtimestamp(last_modified_time).strftime('%Y-%m-%d %H:%M:%S')
                log_files.append({'name': filename, 'path': log_path, 'last_modified': last_modified_date})

        # Sort logs by last modified date, latest first
        log_files.sort(key=lambda x: x['last_modified'], reverse=True)

        return render_template('logs.html', logs=log_files)

    except Exception as e:
        return f"Error listing logs: {str(e)}"


@app.route('/view_log')
def view_log():
    log_path = request.args.get('path')
    try:
        with open(log_path, 'r') as log_file:
            log_content = log_file.read()
        
        # Render the 'view_log.html' template, passing the log content
        return render_template('view_log.html', log_content=log_content)
    
    except Exception as e:
        return f"Error reading log: {str(e)}"




def get_available_partitions():
    try:
        result = subprocess.run(['lsblk', '--json'], capture_output=True, check=True)
        devices = json.loads(result.stdout)

        partitions = []
        for device in devices['blockdevices']:
            if 'children' in device:
                for child in device['children']:
                    if "mmcblk" in child['name']:
                        continue
                    size_str = child['size']
                    if 'G' in size_str:
                        size = float(size_str.replace('G', ''))
                    elif 'T' in size_str:
                        size = float(size_str.replace('T', '')) * 1024
                    else:
                        size = 0
                    if size >= 1:
                        partitions.append({
                            'name': f"/dev/{child['name']}",
                            'size': f"{size:.2f} GB" if size < 1024 else f"{size / 1024:.2f} TB"
                        })
        return partitions
    except Exception as e:
        return []

def get_folder_size(folder):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(folder):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def list_folders_with_sizes(directory):
    folders = []
    for item in os.listdir(directory):
        # Exclude hidden files and directories
        if item.startswith('.'):
            continue

        item_path = os.path.join(directory, item)
        if os.path.isdir(item_path):
            size = get_folder_size(item_path)
            size_gb = size / (1024 ** 3)
            folders.append({'name': item, 'size': f"{size_gb:.2f} GB"})
    return folders

@app.route('/')
def index():
    partitions = get_available_partitions()
    return render_template('index.html', status=status, partitions=partitions)

@app.route('/mount', methods=['POST'])
def mount():
    global status
    source = request.form['source']
    destination = request.form['destination']

    try:
        if os.path.ismount('/mnt/usb/source'):
            subprocess.run(['umount', '/mnt/usb/source'], check=True)
        if os.path.ismount('/mnt/usb/destination'):
            subprocess.run(['umount', '/mnt/usb/destination'], check=True)

        subprocess.run(['mount', source, '/mnt/usb/source'], check=True)
        subprocess.run(['mount', destination, '/mnt/usb/destination'], check=True)

        status = f"Successfully mounted {source} to /mnt/usb/source and {destination} to /mnt/usb/destination."
        source_folders = list_folders_with_sizes('/mnt/usb/source')
        destination_folders = list_folders_with_sizes('/mnt/usb/destination')

        return redirect(url_for('folder_selection', source_folders=json.dumps(source_folders), destination_folders=json.dumps(destination_folders)))

    except subprocess.CalledProcessError as e:
        status = f"Failed to mount: {str(e)}"
        return render_template('index.html', status=status, partitions=get_available_partitions())

@app.route('/folder_selection')
def folder_selection():
    source_folders = json.loads(request.args.get('source_folders', '[]'))
    destination_folders = json.loads(request.args.get('destination_folders', '[]'))
    return render_template('folder.html', source_folders=source_folders, destination_folders=destination_folders)


import os
import subprocess
import time

def copy_files(source, destination):
    global copy_progress, overall_progress, copy_complete

    # Create logs directory if it doesn't exist
    os.makedirs('log', exist_ok=True)

    # Define log file path
    log_filename = time.strftime("log/copy_%Y%m%d_%H%M%S.log")

    # Remove old logs, keep only the last 10
    log_files = sorted([f for f in os.listdir('log') if f.startswith('copy_')], reverse=True)
    for old_log in log_files[10:]:
        os.remove(os.path.join('log', old_log))

    try:
        # Initialize variables before copying starts
        source_size = get_folder_size(source)
        files_copied = 0
        copied_files = []

        # Create the log file and write the final copy summary at the top
        with open(log_filename, 'w') as log_file:
            # Write the final copy summary at the top
            log_file.write("Final Copy Summary:\n")
            log_file.write(f"Source: {source}\n")
            log_file.write(f"Destination: {destination}\n")
            log_file.write(f"Total Data Copied: {source_size / (1024 ** 3):.2f} GB\n")
            log_file.write("Files Copied:\n")

            # Writing file names (or last 10 as an example)
            for file in os.listdir(source)[:10]:  # Just as an example, modify as needed
                log_file.write(f"{file}\n")
            
            log_file.write("\n")

            # Now write the copy summary below the final summary
            log_file.write("Copy Summary:\n")
            log_file.write(f"Total Data to be Copied: {source_size / (1024 ** 3):.2f} GB\n")
            log_file.write("Files to be copied:\n")

            for file in os.listdir(source)[:10]:  # Just as an example
                log_file.write(f"{file}\n")
            
            log_file.write("\nStarting copy process...\n")
            log_file.flush()

            # Start the rsync process to copy files
            process = subprocess.Popen(
                ['rsync', '-a', '--info=progress2', '--progress', '--inplace', '--exclude', '.*', '--exclude', '*/.*', source, destination],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            while True:
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break

                # Log progress and file names
                if "to-check" in output:  # Progress-related output
                    copy_progress = f"Copying files... {output.strip()}"
                    log_file.write(output)
                    log_file.flush()

                elif output.strip() and not output.startswith(" "):  # Likely a file name (excluding directories)
                    filename = output.strip()
                    if not filename.endswith('/'):  # Exclude directories
                        copied_files.append(filename)
                        files_copied += 1
                        log_file.write(f"Copied: {filename}\n")
                        log_file.flush()

                # Update progress percentage
                destination_size = get_folder_size(destination)
                if source_size > 0:
                    overall_progress = (destination_size / source_size) * 100
                else:
                    overall_progress = 0

            # Check rsync process completion status
            if process.returncode == 0:
                copy_progress = "Copy completed successfully."
                overall_progress = 100
                copy_complete = True
            else:
                error_output = process.stderr.read()
                log_file.write(f"\nError: {error_output}\n")
                log_file.flush()
                copy_progress = f"Failed to copy: {error_output.strip()} - Error code: {process.returncode}"
                overall_progress = 0
                copy_complete = False

            # Final copy summary at the bottom after the copy is done
            log_file.write("\nFinal Copy Summary:\n")
            log_file.write(f"Total Data Copied: {destination_size / (1024 ** 3):.2f} GB\n")
            log_file.write(f"Total Files Copied: {files_copied}\n")
            log_file.write("Files Copied:\n")
            for file in copied_files:
                log_file.write(f"{file}\n")
            log_file.write("\n")

    except Exception as e:
        copy_progress = f"Failed to copy: {e}"
        overall_progress = 0
        copy_complete = False


@app.route('/start_copy', methods=['POST'])
def start_copy():
    global copy_progress, overall_progress, copy_complete
    copy_progress = "Copying..."
    overall_progress = 0
    copy_complete = False  # Reset the flag before starting a new copy

    source_folder = request.form['source_folder']
    destination_folder = request.form['destination_folder']

    source_path = os.path.join('/mnt/usb/source', source_folder) + '/'
    destination_path = os.path.join('/mnt/usb/destination', destination_folder)

    copy_thread = threading.Thread(target=copy_files, args=(source_path, destination_path))
    copy_thread.start()

    source_folders = list_folders_with_sizes('/mnt/usb/source')
    destination_folders = list_folders_with_sizes('/mnt/usb/destination')

    return redirect(url_for('progress_page', source_folders=json.dumps(source_folders), destination_folders=json.dumps(destination_folders)))

@app.route('/progress')
def progress_page():
    global copy_progress, overall_progress
    return render_template('progress.html', copy_progress=copy_progress, overall_progress=overall_progress)

@app.route('/progress_status')
def progress_status():
    global copy_progress, overall_progress, copy_complete
    source_folders = list_folders_with_sizes('/mnt/usb/source')
    destination_folders = list_folders_with_sizes('/mnt/usb/destination')
    return jsonify(copy_progress=copy_progress, overall_progress=overall_progress, copy_complete=copy_complete, source_folders=source_folders, destination_folders=destination_folders)

@app.route('/create_folder', methods=['POST'])
def create_folder():
    global status
    mount_point = request.form['mount_point']
    new_folder_name = request.form['new_folder_name']

    try:
        subprocess.run(['mkdir', '-p', os.path.join(mount_point, new_folder_name)], check=True)
        status = f"Folder '{new_folder_name}' created successfully in {mount_point}."
    except subprocess.CalledProcessError as e:
        status = f"Failed to create folder in {mount_point}: {str(e)}"

    return redirect(url_for('folder_selection', source_folders=json.dumps(list_folders_with_sizes('/mnt/usb/source')), destination_folders=json.dumps(list_folders_with_sizes('/mnt/usb/destination'))))

if __name__ == '__main__':
    app.run(debug=True, host='0.0.0.0')

